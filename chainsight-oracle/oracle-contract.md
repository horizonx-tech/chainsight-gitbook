# Oracle Contract

### Price Feed Oracle Contract

Chainsight typically deploys an **`Oracle`** contract on the target EVM chain, which can store arbitrary data keyed by `(sender, key)`. Below is a simplified explanation of how it works:

```solidity
function updateStateByKey(
        bytes calldata _data,
        bytes32 key
 ) external override {
    // Store the price data under (msg.sender, key).
    // The block timestamp is recorded for checking the updated time.
}

function readAsUint256WithTimestamp(address sender, bytes32 key)
    external view
    returns (uint256, uint64)
{
    // Return the uint256 value plus the timestamp
}

// Overloads for other data types (string, int256, etc.)
```

**Key Points & Interface Highlights**

1. **`updateStateByKey(...)`**
   * Chainsight (or any authorized sender) writes data to the contract, specifying a unique `key` (often a `bytes32` that references the price feed name or asset).
   * The contract automatically timestamps each update.
2. **`readAsUint256WithTimestamp(...)`**
   * DApps call this to retrieve the stored 256-bit integer plus the last update’s timestamp. It’s the primary function for price retrieval.
   * The contract also supports `readAsString...`, `readAsInt...`, etc., for more advanced or text-based data.

**In short,** developers can read the most up-to-date on-chain data by calling `readAsUint256ByKey(sender, key)`, receiving the integer plus a timestamp.

### Writing Data to Each Chain

Internally, **chainsight** uses a distributed node approach with threshold ECDSA based on the chain-key cryptography:

1. **Canister Node Collects or Generates Data**
   * The node network finalizes data (like a price or time-series point).
2. **Threshold Signing**
   * The node network collectively signs an EVM transaction using a shared private key (generated by DKG).
   * This private key is never held by a single party. Instead, each node holds a partial share—**only** by combining a threshold of shares can they produce a valid signature.
3. **Transaction Submission**
   * The final signed transaction is broadcast to the EVM chain, calling `updateStateByKey(...)` on the `Oracle` contract.
   * No external bridging contract is required, as the node network “natively” signs an Ethereum-compatible tx.

**Note**: This entire process is cryptographically distributed. No single node can forge or block updates, ensuring decentralized reliability.
